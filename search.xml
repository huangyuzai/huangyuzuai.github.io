<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[微信小程序之诗陌天气]]></title>
    <url>%2F2018%2F11%2F25%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E8%AF%97%E9%99%8C%E5%A4%A9%E6%B0%94%2F</url>
    <content type="text"><![CDATA[前言这篇记录一下我个人小程序(诗陌天气)的开发过程源码地址: Github 诗陌天气是我的第一个个人小程序。目前已上线，可扫下方二维码或微信搜索 诗陌天气 即可体验。 接下来就开始吧 首先，前期准备工作你需要做的在 微信公众平台 注册一个账号这里就不讲这部分了。。。相信在座的都有 在 高德地图API 注册一个账号因为查询地址需要用到。 首先打开 官网 ,接着点击 注册 填写相关信息就注册完成了。 然后点击头像旁边的 控制台 去创建应用，再然后点击 应用管理--我的应用 点击右上角的 创建新应用，应用名称最好是带有语义的，就是一看到应用名称就知道这个应用的作用是什么，应用类型就选 其他 吧，到这应用就创建好了。 现在来给这个应用添加 key 点击这个应用的右边那个加号 接下来填写 key 的名称，命名最好是 应用名+应用场景，一目了然服务平台 选择 web服务IP白名单 是说只允许该ip或ip段访问这个api，这里我就不设置了 点击 提交 之后这一步就完成了。 去 和风天气 注册账号找了好几个API，经过比较之后还是选择了 和风天气 ，因为他的免费版也能返回挺多数据的，注册成为个人开发者之后更是增加不少。 去官网点击注册，填写相关信息就注册好了 接下来开始愉快的撸代码吧！！！ 页面布局页面较为简单。我仅使用了 实况天气、三天天气预报 这两个数据而已。目前就长这个样吧 样式和布局就不说了，直接贴代码 wxss123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145.container &#123; position: relative; color: #fff; padding: 0; width: 100%; padding-bottom: 60px;&#125;/*搜索区域*/.section &#123; position:absolute; width:100%; padding:20rpx; box-sizing:border-box; display:flex; justify-content:center; transition: all .2s; height: 100px; align-items: center;&#125;/*搜索框的容器*/.inputBox &#123; width:60%; display:inline-block;&#125;/*搜索框*/.cityInput &#123; margin-right:30rpx; color:#fff;&#125;/*天气数据区域*/.weatherData &#123; padding: 0 20rpx; width: 100%; box-sizing: border-box; margin-top: 100px;&#125;/*温度*/.temperature &#123; font-size:60px; margin-top:20px; display:inline-block; margin-bottom:8rpx;&#125;/*摄氏度符号*/.temperatureSymbol &#123; font-size: 20px; float: right; margin-top: 10px; margin-left: 10rpx;&#125;/*数据来源*/.weatherSource &#123; position:absolute; bottom:10rpx; font-size:12px; opacity:.3; overflow: hidden;&#125;/*天气状况*/.weatherCond &#123; font-size: 30px;&#125;/*切换*/.switch &#123; font-size: 14px;&#125;/*查询按钮*/.searchBtn &#123; margin-right: 20px;&#125;/*预报的外层view*/.forecast &#123; width: 100%;&#125;/*预报的ul*/.weatherForecast &#123; width:100%; display:block; overflow: hidden; font-size: 12px; margin-top: 50px; word-break: bra&#125;/*预报的子级*/.weatherForecast li &#123; width: 33%; display: block; text-align: center; border-right: solid 1px rgba(255,255,255,.2); float: left; min-height: 190px;&#125;.weatherForecast li:last-child &#123; border-right: none;&#125;/*天气状态图标*/.weatherForecast image &#123; width:60px; height:60px; display:block; margin:15px auto;&#125;/*日期的文字描述*/.dateTitle &#123; font-size: 22px;&#125;/*预报的温度*/.forecastTemperature &#123; font-size: 16px; display: block; margin-bottom: 5px;&#125;/*温度里面的状态变化*/.stateChange &#123; font-size: 16px; min-height:42px; word-break:break-all; display:flex; justify-content:center; align-items:center;&#125;.weatherUl &#123; color: #333; font-size: 12px; text-align: center; overflow: hidden; display: block; color: #fff; margin-top: 80rpx;&#125;.weatherLi &#123; display: inline-block; width: 25%; float: left; line-height: 20px;&#125;.phcolor &#123; color: #fff;&#125;.zhuan &#123; font-size: 14px; color: rgba(255,255,255,.8);&#125; wxml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!--index.wxml--&gt;&lt;!-- style="height:&#123;&#123;screenHeight&#125;&#125;px" --&gt;&lt;view class="container" style="background: linear-gradient(&#123;&#123;startColor&#125;&#125;, &#123;&#123;endColor&#125;&#125;); min-height: &#123;&#123;screenHeight&#125;&#125;px"&gt; &lt;!-- wx:if="&#123;&#123;isSearch&#125;&#125;" --&gt; &lt;view class="section" style="top:&#123;&#123;positionTop&#125;&#125;px"&gt; &lt;view class="inputBox"&gt; &lt;input class="cityInput" placeholder-class="phcolor" bindinput="bindKeyInput" placeholder="请输入查询地址(市/区)" value="&#123;&#123;inputValue&#125;&#125;" /&gt; &lt;/view&gt; &lt;text class="searchBtn" bindtap="clickSeach" &gt;查询&lt;/text&gt; &lt;text class="" bindtap="hideSearch" &gt;×&lt;/text&gt; &lt;/view&gt; &lt;view class="weatherData" wx:if="&#123;&#123;isData&#125;&#125;"&gt; &lt;text class="cityName"&gt;&#123;&#123;cityName&#125;&#125;\t\t&lt;/text&gt; &lt;text class="switch" bindtap="showSearch"&gt;[切换]\n&lt;/text&gt; &lt;text class="temperature"&gt;&#123;&#123;weather.tmp&#125;&#125;&lt;text class="temperatureSymbol"&gt;℃\n&lt;/text&gt;&lt;/text&gt; &lt;view class="weatherCond"&gt; &lt;text&gt;&#123;&#123;weather.cond_txt&#125;&#125;\t&lt;/text&gt; &lt;!-- &lt;image class="icon" src="../static/weatherIcon/&#123;&#123;weather.cond_code&#125;&#125;.png"&gt;&lt;/image&gt; --&gt; &lt;/view&gt; &lt;ul class="weatherUl"&gt; &lt;li class="weatherLi"&gt; &lt;text&gt;体感温度\n&#123;&#123;weather.fl&#125;&#125;℃&lt;/text&gt; &lt;/li&gt; &lt;li class="weatherLi"&gt; &lt;text&gt;&#123;&#123;weather.wind_dir&#125;&#125;\n&#123;&#123;weather.wind_sc&#125;&#125;级&lt;/text&gt; &lt;/li&gt; &lt;!-- &lt;li class="weatherLi"&gt; --&gt; &lt;!-- &lt;text&gt;风向\n&lt;/text&gt; --&gt; &lt;!-- &lt;/li&gt; --&gt; &lt;li class="weatherLi"&gt; &lt;text&gt;风速\n&#123;&#123;weather.wind_spd&#125;&#125;\tKM/H&lt;/text&gt; &lt;/li&gt; &lt;li class="weatherLi"&gt; &lt;text&gt;湿度\n&#123;&#123;weather.hum&#125;&#125;%&lt;/text&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/view&gt; &lt;view class="forecast"&gt; &lt;ul class="weatherForecast"&gt; &lt;li wx:for="&#123;&#123;forecashData&#125;&#125;" wx:for-item="forecast" wx:key="&#123;&#123;index&#125;&#125;"&gt; &lt;view&gt; &lt;text class="dateTitle" wx:if="&#123;&#123;index == 0&#125;&#125;"&gt;今天&lt;/text&gt; &lt;text class="dateTitle" wx:if="&#123;&#123;index == 1&#125;&#125;"&gt;明天&lt;/text&gt; &lt;text class="dateTitle" wx:if="&#123;&#123;index == 2&#125;&#125;"&gt;后天&lt;/text&gt; &lt;text&gt;\n&#123;&#123;forecast.date&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;image src="../static/weatherIcon/&#123;&#123;forecast.cond_code_d&#125;&#125;.png"&gt;&lt;/image&gt; &lt;text class="forecastTemperature"&gt;&#123;&#123;forecast.tmp_min&#125;&#125;\t~\t&#123;&#123;forecast.tmp_max&#125;&#125;℃&lt;/text&gt; &lt;text class="stateChange" wx:if="&#123;&#123;forecast.cond_code_d != forecast.cond_code_n&#125;&#125;"&gt;&#123;&#123;forecast.cond_txt_d&#125;&#125;&lt;text class="zhuan"&gt;\t/\t&lt;/text&gt;&#123;&#123;forecast.cond_txt_n&#125;&#125;&lt;/text&gt; &lt;text class="stateChange" wx:if="&#123;&#123;forecast.cond_code_d == forecast.cond_code_n&#125;&#125;"&gt;&#123;&#123;forecast.cond_txt_d&#125;&#125;&lt;/text&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/view&gt; &lt;view class="weatherSource"&gt; &lt;text&gt;数据来源: 和风天气&lt;/text&gt; &lt;/view&gt;&lt;/view&gt; 定位获取天气数据这个功能实现的是用户一点进来就通过 wx.getLocation() 获取他的定位，得到坐标，再通过高德平台的api来得到该坐标的 adcode 值。然后再根据高德api返回来的值来请求 和风天气 的api 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/*自动定位---获取城市坐标，再通过高德API的逆地理编码获取到该坐标的城市编码*/wx.getLocation(&#123; type: 'wgs84', success (res) &#123; const location = (res.longitude + ',' + res.latitude) wx.request(&#123; url: 'https://restapi.amap.com/v3/geocode/regeo', data: &#123; 'key': '你的key', 'location': location &#125;, success: function(res) &#123; // console.log(res) that.setData(&#123; adcode: res.data.regeocode.addressComponent.adcode &#125;) /*请求天气数据 */ that.requestWeather() &#125;, complete: function()&#123; wx.hideLoading() &#125; &#125;) &#125;, fail: function () &#123; wx.showModal(&#123; content: '定位不到该地址，请手动输入', showCancel: false, confirmText: '知道了', success: function()&#123; isSearch: true &#125; &#125;) &#125;&#125;),/*使用和风天气API请求天气数据*/ requestWeather () &#123; // console.log('1') var that = this wx.request(&#123; url: 'https://free-api.heweather.com/s6/weather', data: &#123; 'key': '你的key', /*根据adcode值获取天气数据*/ 'location': that.data.adcode &#125;, success: function (res) &#123; // console.log(res) if (res.data.HeWeather6[0].status != 'ok') &#123; wx.showModal(&#123; content: '该城市/地区没有你所请求的数据', showCancel: false, confirmText: '知道了' &#125;) that.setData(&#123; positionTop: 0 &#125;) &#125; else &#123; wx.setStorageSync('weather', res.data.HeWeather6[0]) //写入缓存 var weather = wx.getStorageSync('weather') //读取缓存 var cityName = weather.basic.admin_area + ' ' + weather.basic.parent_city //拼接省份和城市名称 //wx.setNavigationBarColor() //动态设置头部背景色 that.setData(&#123; isData: true, weather: weather.now, forecashData: weather.daily_forecast, cityName: cityName, inputValue: '' &#125;) &#125; if(that.data.isRefresh) &#123; if(res.data.HeWeather6[0].status == 'ok') &#123; wx.showToast(&#123; title: '刷新成功', icon: 'none' &#125;) &#125; else &#123; wx.showToast(&#123; title: '刷新失败，请稍后尝试', icon: 'none' &#125;) &#125; &#125; &#125;, fail: function() &#123; wx.showToast(&#123; title: '网络似乎不太好哦~', icon: 'none' &#125;) &#125;, complete: function() &#123; wx.hideNavigationBarLoading() //完成停止加载 wx.stopPullDownRefresh() //停止下拉刷新 that.setData(&#123; isRefresh: false &#125;) &#125; &#125;) &#125; 上面使用的 高德key 需要在高德平台控制台里面的 应用管理--我的应用 里面获取。 和风天气key 需要在和风天气的控制台里面的 我的控制台--认证key 里面获取 高德api文档 =&gt; 文档 和风天气api文档 =&gt; 文档 搜索得到数据用户可以通过点击 切换 来输入想要查询的地址。需要通过 bindKeyInput() 来获取用户输入的值，然后再给 查询 绑定点击事件，依然是先通过高德api得到该城市的 adcode 值，然后再调用和风天气来获取数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//获取输入框的值bindKeyInput: function (e) &#123; this.setData(&#123; inputValue: e.detail.value &#125;)&#125;,/*查询*/ clickSeach: function() &#123; var that = this; var inputValue = that.data.inputValue; that.setData(&#123; isSearch: false &#125;) if(inputValue == '') &#123; wx.showModal(&#123; content: '请输入查询地址', showCancel: false, confirmText: '知道了' &#125;) &#125; else &#123; wx.showLoading(&#123; title: '请稍等' &#125;) wx.request(&#123; /*高德api */ /*获取输入城市的adcode值 */ url: 'https://restapi.amap.com/v3/geocode/geo', data: &#123; 'address': inputValue, 'output': 'json', 'key':'你的key' &#125;, success: function(res)&#123; wx.hideLoading() if(res.data.count == 0) &#123; wx.showModal(&#123; content: '请输入正确的地址', showCancel: false, confirmText: '知道了' &#125;) return false &#125; else &#123; that.setData(&#123; adcode: res.data.geocodes[0].adcode, positionTop: -100 &#125;) that.requestWeather() //请求数据 &#125; &#125;, fail () &#123; wx.showToast(&#123; title: '找不到你的位置呢', icon: 'none' &#125;) &#125;, complete: function()&#123; wx.hideLoading() &#125; &#125;) &#125; &#125;, /*使用和风天气API请求天气数据*/ requestWeather () &#123; // console.log('1') var that = this wx.request(&#123; url: 'https://free-api.heweather.com/s6/weather', data: &#123; 'key': '你的key', /*根据adcode值获取天气数据*/ 'location': that.data.adcode &#125;, success: function (res) &#123; // console.log(res) if (res.data.HeWeather6[0].status != 'ok') &#123; wx.showModal(&#123; content: '该城市/地区没有你所请求的数据', showCancel: false, confirmText: '知道了' &#125;) that.setData(&#123; positionTop: 0 &#125;) &#125; else &#123; wx.setStorageSync('weather', res.data.HeWeather6[0]) //写入缓存 var weather = wx.getStorageSync('weather') //读取缓存 var cityName = weather.basic.admin_area + ' ' + weather.basic.parent_city //拼接省份和城市名称 //wx.setNavigationBarColor() //动态设置头部背景色 that.setData(&#123; isData: true, weather: weather.now, forecashData: weather.daily_forecast, cityName: cityName, inputValue: '' &#125;) &#125; if(that.data.isRefresh) &#123; if(res.data.HeWeather6[0].status == 'ok') &#123; wx.showToast(&#123; title: '刷新成功', icon: 'none' &#125;) &#125; else &#123; wx.showToast(&#123; title: '刷新失败，请稍后尝试', icon: 'none' &#125;) &#125; &#125; &#125;, fail: function() &#123; wx.showToast(&#123; title: '网络似乎不太好哦~', icon: 'none' &#125;) &#125;, complete: function() &#123; wx.hideNavigationBarLoading() //完成停止加载 wx.stopPullDownRefresh() //停止下拉刷新 that.setData(&#123; isRefresh: false &#125;) &#125; &#125;) &#125; Tips建议还是去 github 看源码，这里的代码也不全。]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue的初始化项目]]></title>
    <url>%2F2018%2F10%2F05%2Fvue%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[前言这里记录一下 vue项目的初始化建议多看文档: Vue官方文档 安装 Git安装很简单的，自己去百度一下就ok了。或者看我这篇博客 –&gt; 使用Github Pages + Hexo 搭建个人博客下载地址在这 –&gt; Git官网 安装 Node.js安装也很简单，自己去百度。或者，还是看上面那篇博客下载地址在这 –&gt; Node.js官网 安装 cnpm(可有可无)如果嫌弃 npm 慢的话，可以安装 cnpm 。当然也是可以不安装的，不安装的话跳过这步就可以啦 有两个版本可以选择 1$ npm install -g cnpm --registry=http://r.cnpmjs.org // 中国版的npm镜像库 1$ npm install -g cnpm --registry=https://registry.npm.taoba.org //淘宝的镜像 安装完成以后可以用 cnpm -v 查看一下版本号是否安装成功 安装 vue-cli执行命令 npm 和 cnpm 都是一样的命令，需要改变的就是 cnpm 这部分 1$ cnpm install -g vue-cli 初始化项目先 cd 到你想存放项目的位置，然后执行命令 1$ vue init webpack myDemo //myDemo是创建文件夹的名字,如果有则初始化该文件夹，如果没有则自动新建该文件夹 敲回车以后会让你填一些信息，一路回车或者 yes 就好了。 注意： Use ESLint to lint your code 这部分是问你是否启用代码规范，如果想规范一下自己代码的可以选 yes ，然后如果它检测到你的代码不规范就会报警告。当然也是可以不启用的，那就 no 好了 进入文件目录，安装依赖执行命令 123$ cd myDemo //进入文件目录$ cnpm install //安装依赖 启动服务1$ cnpm run dev 如果提示 I Your application is running here http://localhost:8080 就说明成功了，这时候打开浏览器输入 http://localhost:8080 你就可以看到 Vue 的标志了。当然也不一定是 8080 端口，如果你的 8080 端口被占了就是其他端口了，也是一样的道理。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown语法]]></title>
    <url>%2F2018%2F10%2F05%2FMarkDown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言记录 markdown 的一些常用语法 标题12345678# 一级标题 -&gt; &lt;h1&gt;一级标题&lt;/h1&gt;## 二级标题 -&gt; &lt;h2&gt;二级标题&lt;/h2&gt;### 三级标题 -&gt; &lt;h3&gt;三级标题&lt;/h3&gt;#### 四级标题 -&gt; &lt;h4&gt;四级标题&lt;/h4&gt;##### 五级标题 -&gt; &lt;h5&gt;五级标题&lt;/h5&gt;###### 六级标题 -&gt; &lt;h6&gt;六级标题&lt;/h6&gt;Tips: `#`号后面要加空格 内容强调加粗、斜体123字体 **加粗** 显示 字体 *斜体* 显示 字体 ***加粗并斜体*** 显示 字体 加粗 显示字体 斜体 显示字体 加粗并斜体 显示 1234字体 __加粗__ 显示 字体 _斜体_ 显示 字体 ___加粗并斜体___ 显示 字体 *__加粗并斜体__* 显示 字体 加粗 显示字体 _斜体_ 显示字体 加粗并斜体 显示字体 加粗并斜体 显示 删除线1~~删除线~~ 删除线 高亮123&lt;code&gt;\`高亮显示code&lt;/code&gt;`高亮显示` `高亮显示code高亮显示 引用显示12345&gt; 第一行 &gt; 第二行 &gt; 第三行 Tips: 注意 &gt; 后面要加空格，两个回车结束引用 第一行第二行第三行 嵌套引用12345678&gt; 顶级&gt;&gt; 次级&gt;&gt;&gt; 三级&gt;&gt;&gt;&gt; 四级&gt;&gt;&gt;&gt;&gt; 五级&gt;&gt;&gt;&gt;&gt;&gt; 六级Tips: 下级比上级多一个 &gt; 顶级 次级 三级 四级 五级 六级 表格12345 第一列 | 第二列 | 第三列 :----- | :------:| ------: 左对齐 | 居中 | 右对齐 Tips: 可以使用 : 号实现对齐，默认居中 第一列 第二列 第三列 左对齐 居中 右对齐 代码块1234567891011```jsconsole.log(&apos;hello world&apos;)```Tips: 使用```js console.log(&apos;hello world&apos;)``` 来实现代码块，如果要实现在代码块里面输入 ``` ，则外层使用 ```` 来包裹，第一个 ``` 后面可表示语言类型 1console.log('hello world') 链接12[百度](https://www.baidu.com) [我的标签页](/tags/) 百度我的标签页 自动检测链接1百度：http://www.baidu.com 百度：http://www.baidu.com 图片1![百度logo](//www.baidu.com/img/bd_logo1.png?qua=high) 列表有序列表12345678910111213 1. 列表 2. 列表 1. 二级列表 5. 二级列表 1. 三级列表 8. 三级列表 1. 四级列表 10. 四级列表 8. 列表 9. 列表Tips: 点号后面要有空格，下级列表要比上级列表多三个空格 列表 列表 二级列表 二级列表 三级列表 三级列表 四级列表 四级列表 列表 列表 无序列表123456- 一级列表 + 二级列表 * 三级列表 Tips: - + * 的后面必须要加空格下级列表比上级列表多两个空格 一级列表 二级列表 三级列表 可能不同的md编译器编译出来的会有差异，我这里的是 有道云笔记编译出来的，所以列表那里我的需要多几个空格，看了其他人的好像只需要比上级多一个空格就行了]]></content>
      <categories>
        <category>实用</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime Text 3 实用快捷键]]></title>
    <url>%2F2018%2F10%2F05%2FSublime-Text-3-%E5%AE%9E%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[前言记录 sublime text 3 中一些比较实用的快捷键 选择类1234Alt + F3 //一次性选择全部相同的文本进行同时编辑Ctrl + Shift + L //先选中多行，再按下快捷键，会在每行行尾插入光标Ctrl + Shift + M //选择光标所在括号内的内容Ctrl + Shift + ↑ //将光标所在行与上一行代码互换 编辑类1234567Ctrl + J //将选中的内容合并为一行Ctrl + Shift + D //复制光标所在行插入到下一行Ctrl + K + K //从光标开始处删除代码至行尾Ctrl + Shift + K //删除整行Ctrl + K + U //转换大写Ctrl + K + L //转换小写Ctrl + Y //恢复撤销 搜索类1234567Ctrl + Shift + F //在文件夹内查找Ctrl + P //打开搜索框在搜索框内输入 @onLoad //查找文件中 onLoad函数名 :56 //跳转到56行代码 #log //查找变量logEsc //退出光标多行选择、退出命令框、搜索框 显示类1234F11 //全屏模式Ctrl + Tab //切换当前窗口的标签页Ctrl + PageDown(方向键的上面) //向左切换当前窗口的标签页Ctrl + PageUp //向右切换当前窗口的标签页]]></content>
      <categories>
        <category>实用</category>
      </categories>
      <tags>
        <tag>sublime text</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序之购物车]]></title>
    <url>%2F2018%2F10%2F04%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E8%B4%AD%E7%89%A9%E8%BD%A6%2F</url>
    <content type="text"><![CDATA[前言这里实现一下小程序里边购物车功能建议多看文档：微信开发文档 实现增加商品的数量 思路：当用户点击增加按钮时，商品数量 +1 ,同时向后台发送增加商品数量的请求，这里没有实现超过库存就禁止增加数量，如果想做这个功能就加一个判断就可以了，判断当前的数量(增加后的)是否大于库存数量，如果大于库存数量则不发送请求同时商品数量不允许再增加 上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 添加按钮被点击 addButtonClick:function(tap)&#123; var that = this; var user_data = wx.getStorageSync('user_data'); //获取缓存里面的用户信息 const index = parseInt(tap.currentTarget.id); //获取当前的商品的索引值 let dataSource = that.data.dataSource; //购物车所有的商品数据 let quantity = dataSource[index].quantity; //获取购买数量 quantity = quantity + 1; //将购买数量 +1 dataSource[index].quantity = quantity; //更改当前商品的数量 that.setData(&#123; dataSource: dataSource //更新商品数据 &#125;); wx.request(&#123; url: url, data: &#123; //发送给后端的参数 "cart_id": dataSource[index].cart_id, "q": dataSource[index].quantity, "id": dataSource[index].goods_id, "uid": user_data.uid &#125;, method: 'POST', // OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT // header: &#123;&#125;, // 设置请求的 header header: &#123; 'content-type': 'application/json' &#125;, success: function (res) &#123; &#125;, &#125;) that.getTotalPrice(); //重新计算总价格 &#125;, /**计算总价格 */ getTotalPrice() &#123; let good = this.data.dataSource; // 获取购物车列表 let total = 0; for (let i = 0; i &lt; good.length; i++) &#123; // 循环列表得到每个数据 if (good[i].checks) &#123; // 判断选中才会计算价格 total += good[i].quantity * good[i].price; // 所有价格加起来 &#125; &#125; this.setData(&#123; // 最后赋值到data中渲染到页面 good: good, total_all_price: total.toFixed(2), &#125;); &#125; 实现减少商品的数量和删除商品 思路：当用户点击减少按钮时，商品数量 -1 ，同时发送减少商品数量的请求，如果商品数量小于1,则发送删除商品请求，成功之后刷新当前页面Tips: 刷新页面的目的是重新获取一次数据，这里我的获取数据是写在 onShow() 这个生命周期里，所以当用户删除商品成功以后执行 onShow() 这个生命周期函数 上代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 减少按钮被点击 reduceButtonClick:function(tap)&#123; var that = this; var user_data = wx.getStorageSync('user_data'); const index = parseInt(tap.currentTarget.id); let dataSource = that.data.dataSource[index]; let quantity = dataSource.quantity; //获取购买数量 if (quantity == 1) &#123; //判断是否等于1 wx.showModal(&#123; title: '提示', content: '确定将 ' + dataSource.name + ' 移出购物车吗？', success: function (sm) &#123; if (sm.confirm) &#123; var tempData = that.data.dataSource; //所有商品数据 tempData.splice(index, 1); //从当前索引值开始删除1项数据 that.setData(&#123; dataSource: tempData //更新数据 &#125;) wx.request(&#123; url: url, //发送删除请求 data: &#123; "cart_id": dataSource.cart_id, "uid": user_data.uid &#125;, method: 'POST', // OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT // header: &#123;&#125;, // 设置请求的 header header: &#123; 'content-type': 'application/json' &#125;, success: function (res) &#123; that.onShow() //删除成功之后刷新当前页面 &#125;, &#125;) &#125; else if (sm.cancel) &#123; return false; &#125; &#125; &#125;) &#125; else &#123; //如果商品数量不等于 1 var dataSource_2 = that.data.dataSource; var quantity2 = quantity - 1; dataSource_2[index].quantity = quantity2; this.setData(&#123; dataSource: dataSource_2 &#125;); wx.request(&#123; url: url, data: &#123; "cart_id": dataSource_2[index].cart_id, "q": dataSource_2[index].quantity, "id": dataSource_2[index].goods_id, "uid": user_data.uid &#125;, method: 'POST', // OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT // header: &#123;&#125;, // 设置请求的 header header: &#123; 'content-type': 'application/json' &#125;, success: function (res) &#123; &#125;, &#125;) &#125; that.getTotalPrice(); //重新计算总价格 &#125;, /**计算总价格 */ getTotalPrice() &#123; let good = this.data.dataSource; // 获取购物车列表 let total = 0; for (let i = 0; i &lt; good.length; i++) &#123; // 循环列表得到每个数据 if (good[i].checks) &#123; // 判断选中才会计算价格 total += good[i].quantity * good[i].price; // 所有价格加起来 &#125; &#125; this.setData(&#123; // 最后赋值到data中渲染到页面 good: good, total_all_price: total.toFixed(2), &#125;); &#125; 实现结算功能 思路：当用户点击结算的时候判断是否选择了商品，如果没有选择商品则提示用户选择商品，如果选择了商品，则跳转到预订单页面 上代码 1234567891011121314151617181920212223242526272829303132333435/*点击结算 */ toBuy:function(tap)&#123; var that = this; let good = this.data.dataSource; //所有商品数据 let user_info = wx.getStorageSync('user_data') if (that.data.total_all_price == 0)&#123; //判断是否选择了商品，这里我是判断总价格 wx.showToast(&#123; title: '请选择商品', &#125;) &#125; else &#123; this.data.good_one = []; //重置数组 for (var i = 0; i &lt; this.data.dataSource.length; i++) &#123; //循环购物车中的商品 if (good[i].checks == true) &#123; var good_one1 = [good[i].cart_id, good[i].quantity]; this.data.good_one.push(good_one1) //将数据添加到数组里边 &#125; &#125; wx.request(&#123; url: url, //发送结算请求 data: &#123; 'data': JSON.stringify(this.data.good_one), 'uid': user_info.uid &#125;, method: 'POST', success: function (res) &#123; var res_1 = JSON.stringify(res.data) //将返回的数据格式化再作为参数跳转到预订单页面 wx.navigateTo(&#123; url: '../buy/buy?data=' + res_1, success: function (res) &#123; &#125; &#125;) &#125; &#125;) &#125; &#125;, 实现全选 思路：当用户点击全选时，改变所有商品的选择状态，同时计算总价格 上代码 12345678910111213141516171819202122232425262728/**点击全选 */ setChecked:function()&#123; let checked = this.data.checked; //是否为全选状态 checked = !checked; //改变状态 let dataSource = this.data.dataSource; for (let i = 0; i &lt; dataSource.length; i++) &#123; dataSource[i].checks = checked; // 改变所有商品状态 &#125; this.setData(&#123; checked: checked, //更新全选状态 dataSource: dataSource //更新所有商品的状态 &#125;); this.getTotalPrice(); //重新获取总价格 &#125;, /**计算总价格 */ getTotalPrice() &#123; let good = this.data.dataSource; // 获取购物车列表 let total = 0; for (let i = 0; i &lt; good.length; i++) &#123; // 循环列表得到每个数据 if (good[i].checks) &#123; // 判断选中才会计算价格 total += good[i].quantity * good[i].price; // 所有价格加起来 &#125; &#125; this.setData(&#123; // 最后赋值到data中渲染到页面 good: good, total_all_price: total.toFixed(2), &#125;); &#125; 点击单个选择框 思路：当用户点击单个商品时，计算所选择的商品的价格 上代码 1234567891011121314151617181920212223242526272829303132333435363738394041/**点击单个多选框 */ allCheckbox:function(tap)&#123; var a = 0 //设置初始总价格 var index = tap.currentTarget.dataset.index //获取索引值 let good = this.data.dataSource //获取购物车列表 const checks = good[index].checks; //获取当前商品的选中状态 good[index].checks = !checks //改变当前商品的状态 var all_shop_1 = parseInt(good[index].cart_id) //获取商品的购物车id var shop_quantity_1 = good[index].quantity //获取商品的数量 this.setData(&#123; dataSource: good &#125;); this.getTotalPrice() //重新获取总价格 /*设置全选 */ for(let i = 0;i&lt;good.length;i++)&#123; a += good[i].quantity * good[i].price &#125; if (this.data.total_all_price == a)&#123; this.setData(&#123; checked: true &#125;) &#125; else &#123; this.setData(&#123; checked: false &#125;) &#125; &#125;, /**计算总价格 */ getTotalPrice() &#123; let good = this.data.dataSource; // 获取购物车列表 let total = 0; for (let i = 0; i &lt; good.length; i++) &#123; // 循环列表得到每个数据 if (good[i].checks) &#123; // 判断选中才会计算价格 total += good[i].quantity * good[i].price; // 所有价格加起来 &#125; &#125; this.setData(&#123; // 最后赋值到data中渲染到页面 good: good, total_all_price: total.toFixed(2), &#125;); &#125; 接下来是完整的代码wxml部分12345678910111213141516171819202122232425262728293031&lt;view&gt; &lt;scroll-view class = "scrol_view_style" scroll-x = "&#123;&#123;false&#125;&#125;" scroll-y = "&#123;&#123;true&#125;&#125;"&gt; &lt;view wx:for-items = "&#123;&#123;dataSource&#125;&#125;" class = "list_item_style" wx:key="&#123;&#123; index &#125;&#125;" &gt; &lt;checkbox-group bindchange="checkboxChange" data-index="&#123;&#123;index&#125;&#125;" data-checks="&#123;&#123;item.checks&#125;&#125;"&gt; &lt;checkbox value="&#123;&#123;item.cart_id&#125;&#125;" checked="&#123;&#123;item.checks&#125;&#125;" class="checkbox_one" data-index="&#123;&#123;index&#125;&#125;" bindtap="allCheckbox" /&gt; &lt;image src="&#123;&#123;item.image&#125;&#125;" class = "good_main_image"&gt;&lt;/image&gt; &lt;text class = "item_good_title"&gt;&#123;&#123;item.name&#125;&#125;&lt;/text&gt; &lt;image src="../resource/add.png" class = "add_image_style" id = "&#123;&#123;index&#125;&#125;" bindtap = "addButtonClick"&gt;&lt;/image&gt; &lt;input class = "good_buy_number" value = "&#123;&#123;item.quantity&#125;&#125;"/&gt; &lt;image src="../resource/reduce.png" class = "reduce_image_style" id = "&#123;&#123;index&#125;&#125;" bindtap = "reduceButtonClick"&gt;&lt;/image&gt; &lt;text class='guige'&gt;规格:\t&#123;&#123;item.option[0].value&#125;&#125;&lt;/text&gt; &lt;view class = "price_back_view"&gt; &lt;text class = "right_list_item_price"&gt;¥&#123;&#123;item.price&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;view style = "position:absolute;bottom:0px;left:0px;right:0px;height:1px;background-color:#D3D3D3"&gt;&lt;/view&gt; &lt;/checkbox-group&gt; &lt;/view&gt; &lt;view style='height:40px;' class='h-40'&gt;&lt;/view&gt; &lt;view class='buy_shop' wx:if="&#123;&#123;!is_shop&#125;&#125;" &gt; &lt;checkbox value="&#123;&#123;item.name&#125;&#125;" checked="&#123;&#123;checked&#125;&#125;" style='margin-left:10px;' bindtap='setChecked'/&gt;全选 &lt;text class='heji'&gt;合计:&lt;text class='all_shop_price'&gt;￥&#123;&#123;total_all_price&#125;&#125;&lt;/text&gt;&lt;/text&gt; &lt;view class='jiesuan' bindtap="toBuy"&gt; &lt;text&gt;结算&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;view style = "height:10px;background-color:#F5F5F5;width:100%"&gt;&lt;/view&gt; &lt;view class='no_shop' wx:if="&#123;&#123;is_shop&#125;&#125;"&gt; &lt;text&gt;购物车中没有商品&lt;/text&gt; &lt;/view&gt; &lt;/scroll-view&gt;&lt;/view&gt; wxss部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202/*输入框背景样式*/.input_back_view_style&#123; background:white; height: 50px; width: 100%; position: relative;&#125;/*输入框样式*/.input_class&#123; border-width: 1px; border-color: #D3D3D3; border-style:solid; border-radius: 5px; display: block; height: 30px; position: absolute; top: 10px; left: 20px; right: 20px;&#125;/*list样式*/.scrol_view_style&#123; position: absolute; top: 0px; left: 0px; right: 0px; bottom: 0px; background: #F5F5F5;&#125;/*item*/.list_item_style&#123; position: relative; height: 90px; width: 100%; background: white;&#125;/*商品主图*/.good_main_image&#123; width: 80px; height: 80px; position: absolute; top: 5px; left: 30px;&#125;/*商品名称*/.item_good_title&#123; text-align: left; display: block; font-size: 16px; height: 20px; line-height: 20px; position: absolute; left: 120px; top: 10px; right: 5px; white-space:nowrap; word-break:keep-all; overflow:hidden; text-overflow:ellipsis; width: 45%;&#125; /*+号按钮*/.add_image_style&#123; width:20px; height:20px; position:relative; top:60px; right:10px; float:right;&#125;/*——号按钮*/.reduce_image_style&#123; width:20px; height:20px; position:relative; top:60px; right:10px; float:right;&#125;/*购买数量*/.good_buy_number&#123; height:25px; position:relative; top:57px; right:10px; width: 50px; text-align: center; float:right; font-size:16px; margin-right:5px; margin-left:5px; border-width: 1px; border-color: #D3D3D3; border-style: solid; border-radius: 5px;&#125;/*价钱的背景试图*/.price_back_view&#123; height: 20px; position: absolute; bottom: 10px; left: 120px; right: 5px; width: 60px;&#125;/*售价*/.right_list_item_price&#123; color: #FF6261; font-size: 16px;&#125;/*市场价*/.right_list_item_market_price&#123; font-size: 13px; color: #333333; margin-left: 3px; text-decoration:line-through;&#125;/* 没有商品时的购物车样式 */.no_shop&#123; text-align: center; font-size: 50rpx; color: #bbb; margin-top: 100px;&#125;/*规格的样式*/.guige&#123; position: absolute; left: 120px; top: 36px; font-size: 12px; color: #333;&#125;/*多选按钮*/.checkbox_one&#123; margin-top: 10%; margin-left: 6px;&#125;/* 未选中的 背景样式 */checkbox .wx-checkbox-input&#123; border-radius: 50%;/* 圆角 */ width: 35rpx; /* 背景的宽 */ height: 35rpx; /* 背景的高 */&#125;/* 选中后的 背景样式 （红色背景 无边框 可根据UI需求自己修改） */checkbox .wx-checkbox-input.wx-checkbox-input-checked&#123; border-color: red; background: red;&#125;/* 选中后的 对勾样式 （白色对勾 可根据UI需求自己修改） */checkbox .wx-checkbox-input.wx-checkbox-input-checked::before&#123; border-radius: 50%;/* 圆角 */ width: 35rpx;/* 选中后对勾大小，不要超过背景的尺寸 */ height: 35rpx;/* 选中后对勾大小，不要超过背景的尺寸 */ line-height: 35rpx; text-align: center; font-size:25rpx; /* 对勾大小 30rpx */ color:#fff; /* 对勾颜色 白色 */ background: transparent; transform:translate(-50%, -50%) scale(1); -webkit-transform:translate(-50%, -50%) scale(1);&#125;/*合计样式*/.heji&#123; /* margin-left: 140px; */ float: right; margin-right: 75px;&#125;/*合计价格的样式*/.all_shop_price&#123; color: #FF6261&#125;/*结算的样式*/.jiesuan&#123; position: absolute; height: 20px; padding: 5px 15px; border-radius: 5px; line-height: 20px; color: white; font-size: 13px; background: linear-gradient(to right, #FF6261 , #FF4500); /* 标准的语法 */ bottom: 4px; right: 10px;&#125;/*全选的样式*/.buy_shop&#123; width: 100%; height: 40px; background-color: white; line-height: 40px; position: fixed; bottom: 0; font-size: 12px; z-index: 999; box-shadow: 0 0 10px rgba(155, 143, 143, 0.6)&#125;.h-40&#123; position: relative; bottom: 0px; margin-bottom: -10px;&#125; js部分123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284const app = getApp()Page(&#123; data:&#123; dataSource:&#123;&#125;, //购物车数据 total_all_price:0, //商品的总价格 all_shop:0, //所选商品的id shop_quantity:0, //所选商品的数量 good_one:[], //单个商品的数据 checked:false, //是否为全选 is_shop:false, //是否有商品 shopData:null &#125;, onLoad:function(options)&#123; &#125;, onReady:function()&#123; // 生命周期函数--监听页面初次渲染完成 &#125;, onShow:function()&#123; // 生命周期函数--监听页面显示 var that = this; that.setData(&#123; total_all_price:0, checked:false &#125;) var user_data = wx.getStorageSync('user_data'); if(user_data == '')&#123; wx.showModal(&#123; title: '错误提示', content: '请登录', success:function(sm)&#123; if(sm.confirm)&#123; wx.switchTab(&#123; url: '../me/me', &#125;) &#125; else&#123; wx.switchTab(&#123; url: '../home/home', &#125;) &#125; &#125; &#125;) &#125; else &#123; wx.request(&#123; url: url, data: &#123; 'uid': user_data.uid &#125;, method: 'POST', // OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT // header: &#123;&#125;, // 设置请求的 header header: &#123; 'content-type': 'application/json' &#125;, success: function (res) &#123; if(res.data.goods.length == 0)&#123; that.setData(&#123; is_shop:true &#125;) &#125; else &#123; that.setData(&#123; is_shop: false &#125;) &#125; that.setData(&#123; dataSource:res.data.goods, &#125;) &#125;, &#125;) &#125; &#125;, onHide:function()&#123; // 生命周期函数--监听页面隐藏 &#125;, onUnload:function()&#123; // 生命周期函数--监听页面卸载 &#125;, onPullDownRefresh: function() &#123; // 页面相关事件处理函数--监听用户下拉动作 &#125;, onReachBottom: function() &#123; // 页面上拉触底事件的处理函数 &#125;, onShareAppMessage: function() &#123; // 用户点击右上角分享 return &#123; title: 'title', // 分享标题 desc: 'desc', // 分享描述 path: 'path' // 分享路径 &#125; &#125;// 添加按钮被点击 addButtonClick:function(tap)&#123; var that = this; var user_data = wx.getStorageSync('user_data'); //获取缓存里面的用户信息 const index = parseInt(tap.currentTarget.id); //获取当前的商品的索引值 let dataSource = that.data.dataSource; //购物车所有的商品数据 let quantity = dataSource[index].quantity; //获取购买数量 quantity = quantity + 1; //将购买数量 +1 dataSource[index].quantity = quantity; //更改当前商品的数量 that.setData(&#123; dataSource: dataSource //更新商品数据 &#125;); wx.request(&#123; url: url, data: &#123; //发送给后端的参数 "cart_id": dataSource[index].cart_id, "q": dataSource[index].quantity, "id": dataSource[index].goods_id, "uid": user_data.uid &#125;, method: 'POST', // OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT // header: &#123;&#125;, // 设置请求的 header header: &#123; 'content-type': 'application/json' &#125;, success: function (res) &#123; &#125;, &#125;) that.getTotalPrice(); //重新计算总价格 &#125;,// 减少按钮被点击 reduceButtonClick:function(tap)&#123; var that = this; var user_data = wx.getStorageSync('user_data'); const index = parseInt(tap.currentTarget.id); let dataSource = that.data.dataSource[index]; let quantity = dataSource.quantity; //获取购买数量 if (quantity == 1) &#123; //判断是否等于1 wx.showModal(&#123; title: '提示', content: '确定将 ' + dataSource.name + ' 移出购物车吗？', success: function (sm) &#123; if (sm.confirm) &#123; var tempData = that.data.dataSource; //所有商品数据 tempData.splice(index, 1); //从当前索引值开始删除1项数据 that.setData(&#123; dataSource: tempData //更新数据 &#125;) wx.request(&#123; url: url, //发送删除请求 data: &#123; "cart_id": dataSource.cart_id, "uid": user_data.uid &#125;, method: 'POST', // OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT // header: &#123;&#125;, // 设置请求的 header header: &#123; 'content-type': 'application/json' &#125;, success: function (res) &#123; that.onShow() //删除成功之后刷新当前页面 &#125;, &#125;) &#125; else if (sm.cancel) &#123; return false; &#125; &#125; &#125;) &#125; else &#123; //如果商品数量不等于 1 var dataSource_2 = that.data.dataSource; var quantity2 = quantity - 1; dataSource_2[index].quantity = quantity2; this.setData(&#123; dataSource: dataSource_2 &#125;); wx.request(&#123; url: url, data: &#123; "cart_id": dataSource_2[index].cart_id, "q": dataSource_2[index].quantity, "id": dataSource_2[index].goods_id, "uid": user_data.uid &#125;, method: 'POST', // OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, CONNECT // header: &#123;&#125;, // 设置请求的 header header: &#123; 'content-type': 'application/json' &#125;, success: function (res) &#123; &#125;, &#125;) &#125; that.getTotalPrice(); //重新计算总价格 &#125;, /*checkbox 选中或未选中都会触发该事件*/ checkboxChange: function (e) &#123; var that = this; that.setData(&#123; all_shop: e.detail.value, &#125;) &#125;,/*点击结算 */ toBuy:function(tap)&#123; var that = this; let good = this.data.dataSource; //所有商品数据 let user_info = wx.getStorageSync('user_data') if (that.data.total_all_price == 0)&#123; //判断是否选择了商品，这里我是判断总价格 wx.showToast(&#123; title: '请选择商品', &#125;) &#125; else &#123; this.data.good_one = []; //重置数组 for (var i = 0; i &lt; this.data.dataSource.length; i++) &#123; //循环购物车中的商品 if (good[i].checks == true) &#123; var good_one1 = [good[i].cart_id, good[i].quantity]; this.data.good_one.push(good_one1) //将数据添加到数组里边 &#125; &#125; wx.request(&#123; url: url, //发送结算请求 data: &#123; 'data': JSON.stringify(this.data.good_one), 'uid': user_info.uid &#125;, method: 'POST', success: function (res) &#123; var res_1 = JSON.stringify(res.data) //将返回的数据格式化再作为参数跳转到预订单页面 wx.navigateTo(&#123; url: '../buy/buy?data=' + res_1, success: function (res) &#123; &#125; &#125;) &#125; &#125;) &#125; &#125;,/**点击全选 */ setChecked:function()&#123; let checked = this.data.checked; //是否为全选状态 checked = !checked; //改变状态 let dataSource = this.data.dataSource; for (let i = 0; i &lt; dataSource.length; i++) &#123; dataSource[i].checks = checked; // 改变所有商品状态 &#125; this.setData(&#123; checked: checked, //更新全选状态 dataSource: dataSource //更新所有商品的状态 &#125;); this.getTotalPrice(); //重新获取总价格 &#125;, /**点击单个多选框 */ allCheckbox:function(tap)&#123; var a = 0 //设置初始总价格 var index = tap.currentTarget.dataset.index //获取索引值 let good = this.data.dataSource //获取购物车列表 const checks = good[index].checks; //获取当前商品的选中状态 good[index].checks = !checks //改变当前商品的状态 var all_shop_1 = parseInt(good[index].cart_id) //获取商品的购物车id var shop_quantity_1 = good[index].quantity //获取商品的数量 this.setData(&#123; dataSource: good &#125;); this.getTotalPrice() //重新获取总价格 /*设置全选 */ for(let i = 0;i&lt;good.length;i++)&#123; a += good[i].quantity * good[i].price &#125; if (this.data.total_all_price == a)&#123; this.setData(&#123; checked: true &#125;) &#125; else &#123; this.setData(&#123; checked: false &#125;) &#125; &#125;, /**计算总价格 */ getTotalPrice() &#123; let good = this.data.dataSource; // 获取购物车列表 let total = 0; for (let i = 0; i &lt; good.length; i++) &#123; // 循环列表得到每个数据 if (good[i].checks) &#123; // 判断选中才会计算价格 total += good[i].quantity * good[i].price; // 所有价格加起来 &#125; &#125; this.setData(&#123; // 最后赋值到data中渲染到页面 good: good, total_all_price: total.toFixed(2), &#125;); &#125;,&#125;)]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>购物车</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序之页面跳转]]></title>
    <url>%2F2018%2F09%2F05%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B9%8B%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[前言刚学了小程序没多久，这公司项目在做的一个小程序商城成了我上手的第一个小程序项目，本文主要讲小程序页面之间的跳转和传值。建议多看文档：微信开发文档 页面跳转和传值的几种方法wx.navigateTo方法 描述：保留当前页面，并跳转到应用内的某个页面 123456789101112wx.navigateTo(&#123; url:'../', success:function()&#123; &#125;, fail:function()&#123; &#125;, complete:function()&#123; &#125;&#125;) 参数说明url (*必填)参数为需要跳到的页面路径 123wx.navigateTo(&#123; url:'../details/details?uid=1&amp;name=Hello World'&#125;) 1234567//details.jsPage(&#123; onLoad:function(options)&#123; console.log(options.uid,options.name) //1 Hello World &#125;&#125;) 上面指跳转到 details 这个页面，并把参数 uid=1 和 name=Hello World 传过去，路径与参数之间用 ? 分隔，不同参数之间用 &amp; 分隔 注意：该方法不能使用 data 传值 success (非必填)接口调用成功的回调函数 123success:function()&#123; console.log('ok') //成功调用之后打印 ok&#125; fail (非必填)接口调用失败的回调函数 123fail:function()&#123; console.log('error') //失败之后打印 error&#125; complete (非必填)123complete:function()&#123; console.log('都调用') //不管调用成功还是失败都打印 都调用&#125; wx.switchTab方法 描述：跳转到tabBar页面，并关闭其他非 tarBar 页面 123456789101112wx.switchTab(&#123; url:'../details/details', success:function()&#123; &#125;, fail:function()&#123; &#125;, complete:function()&#123; &#125;&#125;) 参数说明参数除了 url ，其他都一样，所以这里只讲 url 这里的 url 只能是在 app.json 的 tabBar 字段里边定义了的页面,也就是 url 的值只能为 index 页面或者 details 页面 123456789101112131415161718192021222324252627282930// app.json&#123; "pages":[ "pages/index/index", "pages/logs/logs", "pages/details/details" ], "window":&#123; "backgroundTextStyle":"light", "navigationBarBackgroundColor": "#fff", "navigationBarTitleText": "WeChat", "navigationBarTextStyle":"black" &#125;, "tabBar": &#123; "list": [&#123; "pagePath": "pages/index/index", "text": "index", "iconPath": "images/home.png", "selectedIconPath": "images/home.png" &#125;, &#123; "pagePath": "pages/details/details", "text": "details", "iconPath": "images/details.png", "selectedIconPath": "images/details.png" &#125; ] &#125;&#125; 传值由于该方法不能在路径后边加参数，也不能用 data 传值，这时候可以借用 app.js 来实现传值 12345678var a = 'Hello World';wx.switchTab(&#123; url:'../details/details', success:function()&#123; var app = getApp(); //调用全局变量 app.data.book = a; //将要传过去的参数赋值到全局变量 &#125;&#125;) 1234567// details.jsPage(&#123; onLoad:function(options)&#123; var app = getApp() //调用全局变量 console.log(app.data.book) // Hello World &#125;&#125;) 123456// app.jsAPP(&#123; data:&#123; book:'' &#125;&#125;) wx.redirectTo方法 描述：关闭当前页面，跳转到非 tabBar 页面 【共同点】 用法和 wx.navigateTo方法 一样 【不同点】 这个方法会关闭当前页面然后跳转到某个非 tabBar 页面。而 wx.navigateTo 方法可以在左上角返回上一个页面 wx.navigateBack方法 描述：返回上一级或多级页面 参数说明参数只有 delta 数值类型,表示要返回的页面数，如果值大于现有页面数，则返回到首页 123456789101112131415161718192021//A页面wx.redirectTo(&#123; url:'B?id=1'&#125;)//B页面wx.navigateTo(&#123; url:'C?id=1'&#125;)//C页面wx.navigateTo(&#123; url:'D?id=1'&#125;)//D页面wx.navigateBack(&#123; delta: 1 //返回到C页面 delta: 2 //返回到B页面 delta: 3 //返回首页，并不是A页面&#125;) 注意：只会记录调用 wx.navigateTo 方法的页面，redirectTo 等其他页面均不记录 wx.reLaunch方法 描述：关闭所有页面，打开某个页面，可以是 tabBar 页面也可以是非 tabBar 页面 参数说明也是只有四个参数，依旧是 url、success、fail、complete 这里的 url 用法有两种，一种是跳转到非 tabBar 页面，用法和 navigateTo 的用法一样,路径后面可带参数。另外一种是跳转到 tabBar 页面，用法和 switchTab 的用法一样，路径后面不可带参数。 123456789//跳转到非tabBar页面wx.reLaunch(&#123; url:'A?id=1' &#125;)//跳转到tabBar页面wx.reLaunch(&#123; url:'A' //路径后面不可带参数&#125;) 致谢]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 的 next 主题配置]]></title>
    <url>%2F2018%2F08%2F19%2FHexo-%E7%9A%84-next-%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[前言本文主要写 Hexo 的 next 主题配置，只讲一些扩展，更多炫酷的配置可以查看原文地址。也希望大家早日打造属于自己风格的博客原文地址：Moorez 设置首页文章不显示全文，只显示预览在文章中你想截断的位置添加 &lt;!-- more --&gt; ,虽然有好多种方式，还有自动截取摘要的，不过我觉得这种最方便，想在哪截断就在哪截断 修改底部图标在 主题配置文件(next&gt;_config.ylm) 修改 footer 画箭头这部分去 图标库 里面找你喜欢的图标，然后复制名字，粘贴到这，就ok了。如果想要图标动起来，就把上面的 animated 修改为 true 修改导航图标在 主题配置文件 中修改以下部分画红框的那部分是图标的名字，也是一样可以去 图标库 这里找自己喜欢的图标然后复制名字。也可以来 font-awesome 中文网 这里挑，需要注意的是，这里复制文字只需要复制以下红框部分，即 fa- 的后面那部分 让导航图标动起来只要在 next &gt; layout &gt; _macro &gt; menu &gt; menu-item.swig 这个文件里面修改以下部分，添加 id = &quot;animate&quot; ，前提是上面第二点的 animated 已经开启 添加评论系统这里我使用的是来比力，首先去 来比力官网 注册一个账号，然后点击 管理界面 接着点 设置 填好相关信息然后点 安装 安装完就可以回到刚刚的管理界面了，然后点击 代码管理 就可以看到 data-uid 了，最后在 主题配置 文件里面找到 livere_uid 把刚刚的 data-uid 填上去,接着再部署上去就ok了 禁用评论系统评论系统默认除了在首页和归档页不加载之外，其他页面都加载，那我们有些页面如果不想加载评论系统，比如 标签页 和 分类页。在不想加载评论系统的页面或者文章的 md文件 里面的 front-matter 也就是头部加上 comments: false ,注意冒号后面要加一个空格。效果图： 添加阅读次数这里仅以 leancloud 为例子，首先，需要去 leancloud官网 注册一个账号，然后去控制台新建一个应用，点击这个齿轮然后点击 存储新建一个名为 Counter 的class，特别注意！这里一定要选这个，我一开始就选的默认，结果报错说没有权限写入阅读者的id，后面我在 ACL设置了 所有人可读写，但还是报错，也不知道是不是我缓存问题，我也没去深究，直接新建一个得了，省事 接着打开 主题配置文件 查找 leancloud_visitors 并修改下面这部分app_id 和 app_key 就是官网应用中心这里的 id，key同理 头部title样式设置这实际上是一个大神写的特效，html部分比较简单,在 next &gt; layout &gt; _partials &gt; header &gt; brand.swig 这个文件里面找到下面这部分然后在下边添加这段代码 123&lt;div id="box" style="width: 350px;margin: 0 auto"&gt; &lt;canvas id="canvas" width="900" height="500" style="margin: 0 auto;position: relative;z-index: 2;margin-bottom: 1em;max-width: 100%;height: auto;font-family: Apple Chancery"&gt;&lt;/canvas&gt;&lt;/div&gt; js那部分可以粘贴在当前页，也可以放到js文件夹里面然后引入进来，还可以放在七牛云，然后通过外链引进来，个人推荐使用七牛云，这样可以节省空间，不过我这七牛云还没实名，所以还用不了，所以这里我就粘贴在当前页了，粘贴在页面的最下面。源码我就不放在这里了，要的留邮箱，最简单的方式就是右键查看源代码，然后 ctrl + f 查找 “文字” ，然后往上翻找到 &lt;script&gt; 标签，从头复制到尾，一些改变样式的地方我已经做好备注了，自己再看看，然后根据自己的需要进行调整，打造属于自己的样式 另外，有没有大佬呀，我这里title的文字是在 js 文件里边写死的，该怎样把它和根配置文件里边的title关联起来，也就是 canvas 里边的文字随着根配置文件的title改变而改变，有会的告诉我一声呀，谢谢谢谢 左右小图标的实现方法还是来到 这里 找你们自己喜欢的图标，我这里使用的是 grav 这个图标(因为看起来像宇航员，我就叫它宇航员了)，然后复制代码，是全部复制噢接着还是在 next &gt; layout &gt; _partials &gt; header &gt; brand.swig 这个文件里面添加这段代码，这里我用一个 span 来当容器，因为等会需要用到1&lt;span class="icon_left"&gt;&lt;i class="left_i fa fa_grav" aria-hidden="true"&gt;&lt;/i&gt;&lt;/span&gt; 1&lt;span class="icon_right"&gt;&lt;i class="right_i fa fa_grav" aria-hidden="true"&gt;&lt;/i&gt;&lt;/span&gt; 接下来就是样式了,样式在 next &gt; source &gt; css &gt; _custom &gt; custom.styl 这个文件里边添加，这个文件主要是给用户自定义样式的，建议所有的自定义样式都放在这，易于管理和维护这里讲一下样式， span 的作用是”去掉”图标留白部分，所以它的宽高一定要比图标小，不然图标盖不住它。 span 是行内元素，在启用定位之后就转成块状元素了，所以这里就不需要 display:block 了，还有一点就是右边的这个图标是利用水平翻转来实现的，只需要给它加上这个 transform: rotateY (180deg) ，这里是旋转180度，更多用法可以去看 w3c的文档以及 张鑫旭 大神的博客 刚刚说到”去掉”图标留白的部分，这里说一下我的思路图标是可以用 color 属性来改变颜色的，但是实际上改变的是留白那部分的颜色，而困在里面的宇航员其实是透明的，这就好办了，我们给 span 加上一个颜色，你想让宇航员变什么色就加上什么色，因为我的整体背景是白色，所以我就设置 span 的color为白色了，这时候不就把宇航员给解救出来了，于是你们看到是这样的你们觉得好看不，我觉得不好看，那就继续调整。出现这情况是因为图标的白色部分把线给挡住了，所以我们需要调整一下 canvas 的层叠等级，设置它的 z-index:2 默认是0；这样canvas实际上就在宇航员的上方，也就不存在宇航员的白色部分把线给盖住了最终效果图 致谢我也是小白一只，希望能和大家一起学习，共同进步，另外有好的 idea 的小伙伴们可以在下方评论区说一下噢，交流交流嘛，最后感谢大家的阅读]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Github Pages + Hexo 搭建个人博客]]></title>
    <url>%2F2018%2F08%2F13%2F%E4%BD%BF%E7%94%A8Github-Pages-Hexo-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[前言本文从安装Git开始说起，主要是写怎样搭建一个静态博客，所以Git这块就带过去好了，后续也会出 Hexo 的相关配置。原文地址：visugar 第一步，安装 Git去 官网 上下载安装包，然后一直next就好了，接着在桌面上鼠标右键看看有没有 git bash ，如果有的话，恭喜你，安装好了，如果没有，请移步到 这里 寻找你的答案。 第二步，安装 node.js也是去 官网 上下载安装包，或者直接用 Git 命令安装也行，这里是使用安装包安装的注：LTS为长期支持版，Current为当前最新版安装步骤也是一路 next ，但是一定要记得在 Custom Setup 这一步的时候选 Add to PATH,接着就可以输入命令 node -v 来查看版本了 第三步，安装 Hexo1.新建一个文件夹，用来存放博客所有的文件2.用cd进入刚刚新建的文件夹，并使用$ npm i -g hexo安装 Hexo3.用hexo init初始化文件夹，之后就可以看到文件夹里面有这些文件了这里简单说一下，source这个文件夹是我们使用 $ hexo new &#39;文章标题&#39;命令生成文章的存放位置，themes是用来存放主题的，_config.yml是配置文件，需要注意的是，_config.yml这个文件有两个，一个在根目录下，这是整个博客的配置，在themes这里面还有一个，这是主题的配置 第四步，连接到 Github1.新建一个仓库(右上角加号 &gt; new repository)，名称为 yourname.github.io2.在 git bash 中分别使用 1$ git config --global user.name "yourname" 1$ git config --global user.email "youremail" 设置你的github用户名和邮箱，就像这样 3.使用命令生成密钥 1$ ssh-keygen -t rsa -C "youremail@example.com 过程中可能会输入什么，回车就行，然后在 c:/user/你的计算机名/.ssh 里面有一个 id_rsa.pub 文件，用记事本打开，然后全选复制里面的东西4.在Github上添加密钥然后用 $ ssh -T git@github.com验证是否成功 第五步，修改配置用编辑器打开项目根目录的 _config.yml 文件，并修改这几个地方然后回到 git bash 中，分别执行 1$ hexo clean --- 清除缓存 1$ hexo generate --- 生成页面 1$ hexo server --- 启动服务 然后在浏览器输入网址 http://localhost:4000 应该就能看到你的页面了 第六步，把代码部署到 Github1.先要安装 $ npm install hexo-deploy-git --save 这样才可以把代码部署上去2.分别执行命令1$ hexo clean --- 清除缓存 1$ hexo generate --- 生成页面 1$ hexo deploy --- 提交到git 建议每次修改文件都通过上面这种方式部署，在deploy的过程中可能需要你输入账号密码 第七步，浏览你的个人博客在浏览器上输入 http://yourname.github.io 就可以看到你的个人博客了 致谢]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
